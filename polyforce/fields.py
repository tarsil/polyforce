from typing import TYPE_CHECKING, Any, Callable, List, Tuple, Type, TypedDict, Union

from typing_extensions import Annotated, Self, Unpack, _SpecialForm, get_args

from ._internal import _representation
from .core import _utils
from .core._polyforce_core import PolyforceUndefined

if TYPE_CHECKING:
    from ._internal._representation import ReprArgs


class _FieldInputs(TypedDict, total=False):
    annotation: Union[Type[Any], None]
    default: Any
    factory: Union[Callable[[], Any], None]
    title: Union[str, None]
    name: Union[str, None]
    description: Union[str, None]


_DefaultValues = {
    "default": ...,
    "factory": None,
    "title": None,
    "description": None,
}


class PolyField(_representation.Representation):
    """
    This class holds the information about a field used in Polyforce.

    The PolyField is used for any field definition regardless if it
    is declared or not.

    You shouldn't be declaring PolyField directly and instead just use the Field(...)
    definition.

    The PolyFields are accessible via PolyModel.poly_fields.

    Attributes:
        annotation: The type annotation of the field.
        default: The default value of the field.
        factory: The default function used to build the default for the field.
        title: The title of the field.
        description: The description of the field.
    """

    __slots__ = (
        "annotation",
        "default",
        "factory",
        "title",
        "name",
        "description",
        "metadata",
        "_attributes_set",
    )

    annotation: Union[Type[Any], None]
    default: Any
    factory: Union[Callable[[], Any], None]
    title: Union[str, None]
    name: Union[str, None]
    description: Union[str, None]
    metadata: List[Any]

    def __init__(self, **kwargs: Unpack[_FieldInputs]) -> None:
        """
        This class should generally not be initialized directly; instead, use the `polyforce.fields.Field` function.
        """
        self._attributes_set = {k: v for k, v in kwargs.items() if v is not PolyforceUndefined}
        kwargs = {  # type: ignore
            k: _DefaultValues.get(k) if v is PolyforceUndefined else v for k, v in kwargs.items()
        }
        self.annotation, metadata = self._extract_annotation(kwargs.get("annotation"))

        default = kwargs.pop("default", PolyforceUndefined)
        if default is Ellipsis:
            self.default = PolyforceUndefined
        else:
            self.default = default

        self.factory = kwargs.pop("factory", None)

        if self.default is not PolyforceUndefined and self.factory is not None:
            raise TypeError("cannot specify both default and factory")

        self.name = kwargs.pop("name", None)

        self.title = kwargs.pop("title", None)
        self.description = kwargs.pop("description", None)
        self.metadata = metadata

        if self.default and self.default != PolyforceUndefined and self.annotation:
            self._validate_default_with_annotation()

    def _extract_type_hint(self, type_hint: Union[Type, tuple]) -> Any:
        """
        Extracts the base type from a type hint, considering typing extensions.

        This function checks if the given type hint is a generic type hint and extracts
        the base type. If not, it returns the original type hint.

        Args:
            type_hint (Union[Type, tuple]): The type hint to extract the base type from.

        Returns:
            Union[Type, tuple]: The base type of the type hint or the original type hint.

        Example:
        ```
        from typing import List, Union

        # Extract the base type from a List hint
        base_type = extract_type_hint(List[int])  # Returns int

        # If the hint is not a generic type, it returns the original hint
        original_hint = extract_type_hint(Union[int, str])  # Returns Union[int, str]
        ```
        """
        origin = getattr(type_hint, "__origin__", type_hint)
        if isinstance(origin, _SpecialForm):
            origin = type_hint.__args__  # type: ignore
        return origin

    def _validate_default_with_annotation(self) -> None:
        """
        Validates if the default is allowed for the type of annotation
        generated by the field.
        """
        if not self.default or self.default == PolyforceUndefined:
            return None

        default = self.get_default()

        type_hint = self._extract_type_hint(self.annotation)
        if not isinstance(default, type_hint):
            raise TypeError(
                f"default '{type(default).__name__}' for field '{self.name}' is not valid for the field type annotation, it must be type '{self.annotation.__name__}'"
            )
        self.default = default

    @classmethod
    def _extract_annotation(
        cls, annotation: Union[Type[Any], None]
    ) -> Tuple[Union[Type[Any], None], List[Any]]:
        """
        Extracts the annotation.
        """
        if annotation is not None:
            if _utils.is_annotated(annotation):
                first_arg, *extra_args = get_args(annotation)
                return first_arg, list(extra_args)
        return annotation, []

    def is_required(self) -> bool:
        """Check if the argument is required.

        Returns:
            `True` if the argument is required, `False` otherwise.
        """
        return self.default is PolyforceUndefined and self.factory is None

    def get_default(self) -> Any:
        """
        Returns the default is
        """
        if self.factory is None:
            return self.default() if callable(self.default) else self.default
        return self.factory()

    @classmethod
    def from_field(cls, default: Any = PolyforceUndefined, **kwargs: Unpack[_FieldInputs]) -> Self:
        """
        Generates a new PolyField from the values provided.
        """
        if "annotation" in kwargs:
            raise TypeError('"annotation" is not permitted as a Field keyword argument')
        return cls(default=default, **kwargs)

    def rebuild_annotation(self) -> Any:
        """Rebuilds the original annotation for use in function signatures.

        If metadata is present, it adds it to the original annotation using an
        `AnnotatedAlias`. Otherwise, it returns the original annotation as is.

        Returns:
            The rebuilt annotation.
        """
        if not self.metadata:
            return self.annotation
        else:
            return Annotated[(self.annotation, *self.metadata)]

    def __repr_args__(self) -> "ReprArgs":
        yield "annotation", _representation.PlainRepresentation(
            _representation.display_as_type(self.annotation)
        )
        yield "required", self.is_required()

        for s in self.__slots__:
            if s == "_attributes_set":
                continue
            if s == "annotation":
                continue
            elif s == "metadata" and not self.metadata:
                continue
            if s == "factory" and self.factory is not None:
                yield "factory", _representation.PlainRepr(
                    _representation.display_as_type(self.factory)
                )
            else:
                value = getattr(self, s)
                if value is not None and value is not PolyforceUndefined:
                    yield s, value


def Field(
    default: Any = PolyforceUndefined,
    *,
    factory: Union[Callable[[], Any], None] = PolyforceUndefined,
    title: Union[str, None] = PolyforceUndefined,  # type: ignore
    name: Union[str, None] = PolyforceUndefined,  # type: ignore
    description: Union[str, None] = PolyforceUndefined,  # type: ignore
) -> Any:
    return PolyField.from_field(
        default=default,
        factory=factory,
        title=title,
        description=description,
        name=name,
    )
